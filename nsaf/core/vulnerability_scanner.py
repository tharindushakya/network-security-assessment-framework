"""
Vulnerability scanner module for NSAF.
Identifies security vulnerabilities and misconfigurations.
"""

import re
import socket
import ssl
import subprocess
import json
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass, field
from datetime import datetime
import requests
from urllib.parse import urljoin
import concurrent.futures

from ..utils.logger import get_logger
from .scanner import ScanResult, HostInfo

logger = get_logger(__name__)

@dataclass
class Vulnerability:
    """Data class for vulnerability information"""
    vuln_id: str
    title: str
    description: str
    severity: str  # critical, high, medium, low, info
    cvss_score: float = 0.0
    cve_id: str = ""
    affected_service: str = ""
    host: str = ""
    port: int = 0
    evidence: str = ""
    remediation: str = ""
    references: List[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)

@dataclass 
class SecurityIssue:
    """Data class for security configuration issues"""
    issue_id: str
    category: str
    title: str
    description: str
    risk_level: str
    host: str
    service: str
    evidence: str
    recommendation: str
    timestamp: datetime = field(default_factory=datetime.now)

class VulnerabilityScanner:
    """Comprehensive vulnerability scanner"""
    
    def __init__(self, timeout: int = 10):
        """
        Initialize VulnerabilityScanner
        
        Args:
            timeout: Request timeout in seconds
        """
        self.timeout = timeout
        self.vulnerabilities = []
        self.security_issues = []
        
        # Load vulnerability database
        self.vuln_db = self._load_vulnerability_database()
        
    def _load_vulnerability_database(self) -> Dict[str, Any]:
        """Load vulnerability signatures and patterns"""
        return {
            'weak_protocols': {
                'telnet': {'port': 23, 'severity': 'high'},
                'ftp': {'port': 21, 'severity': 'medium'},
                'http': {'port': 80, 'severity': 'medium'},
                'snmp': {'port': 161, 'severity': 'medium'}
            },
            'weak_ssl_ciphers': [
                'NULL', 'EXPORT', 'DES', 'RC4', 'MD5'
            ],
            'default_credentials': {
                'admin:admin', 'admin:password', 'root:root',
                'admin:', ':admin', 'guest:guest'
            },
            'common_paths': [
                '/admin', '/administrator', '/login', '/wp-admin',
                '/phpmyadmin', '/backup', '/config', '/.git'
            ]
        }

    def assess(self, scan_results: Dict[str, List[ScanResult]]) -> Dict[str, Any]:
        """
        Perform comprehensive vulnerability assessment
        
        Args:
            scan_results: Results from network scanning
            
        Returns:
            Dictionary containing vulnerability assessment results
        """
        logger.info("Starting vulnerability assessment")
        
        assessment_results = {
            'vulnerabilities': [],
            'security_issues': [],
            'summary': {},
            'recommendations': []
        }
        
        for host, results in scan_results.items():
            logger.info(f"Assessing vulnerabilities for {host}")
            
            # Check for various vulnerability types
            self._check_weak_protocols(host, results)
            self._check_ssl_vulnerabilities(host, results)
            self._check_web_vulnerabilities(host, results)
            self._check_default_credentials(host, results)
            self._check_information_disclosure(host, results)
            self._check_misconfigurations(host, results)
            
        assessment_results['vulnerabilities'] = self.vulnerabilities
        assessment_results['security_issues'] = self.security_issues
        assessment_results['summary'] = self._generate_summary()
        assessment_results['recommendations'] = self._generate_recommendations()
        
        logger.info(f"Assessment complete. Found {len(self.vulnerabilities)} vulnerabilities and {len(self.security_issues)} security issues")
        
        return assessment_results

    def _check_weak_protocols(self, host: str, results: List[ScanResult]) -> None:
        """Check for weak or insecure protocols"""
        for result in results:
            service = result.service.lower()
            
            if service in self.vuln_db['weak_protocols']:
                vuln_info = self.vuln_db['weak_protocols'][service]
                
                vulnerability = Vulnerability(
                    vuln_id=f"WEAK_PROTO_{service.upper()}_{host}_{result.port}",
                    title=f"Insecure Protocol: {service.upper()}",
                    description=f"The service {service.upper()} is running on {host}:{result.port}. This protocol transmits data in clear text.",
                    severity=vuln_info['severity'],
                    affected_service=service,
                    host=host,
                    port=result.port,
                    evidence=f"Service {service} detected on port {result.port}",
                    remediation=f"Consider using secure alternatives to {service.upper()}",
                    references=[
                        "https://owasp.org/www-community/vulnerabilities/Insecure_Transport"
                    ]
                )
                self.vulnerabilities.append(vulnerability)

    def _check_ssl_vulnerabilities(self, host: str, results: List[ScanResult]) -> None:
        """Check for SSL/TLS vulnerabilities"""
        ssl_ports = [443, 993, 995, 8443]
        
        for result in results:
            if result.port in ssl_ports or 'ssl' in result.service.lower() or 'tls' in result.service.lower():
                try:
                    # Check SSL configuration
                    ssl_issues = self._analyze_ssl_configuration(host, result.port)
                    
                    for issue in ssl_issues:
                        vulnerability = Vulnerability(
                            vuln_id=f"SSL_{issue['type']}_{host}_{result.port}",
                            title=f"SSL/TLS Issue: {issue['title']}",
                            description=issue['description'],
                            severity=issue['severity'],
                            affected_service=result.service,
                            host=host,
                            port=result.port,
                            evidence=issue['evidence'],
                            remediation=issue['remediation']
                        )
                        self.vulnerabilities.append(vulnerability)
                        
                except Exception as e:
                    logger.debug(f"SSL analysis failed for {host}:{result.port}: {e}")

    def _analyze_ssl_configuration(self, host: str, port: int) -> List[Dict[str, str]]:
        """Analyze SSL/TLS configuration"""
        issues = []
        
        try:
            # Create SSL context
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            # Connect and get certificate info
            with socket.create_connection((host, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check cipher strength
                    if cipher and len(cipher) >= 3:
                        cipher_name = cipher[0]
                        protocol = cipher[1]
                        
                        # Check for weak ciphers
                        for weak_cipher in self.vuln_db['weak_ssl_ciphers']:
                            if weak_cipher in cipher_name:
                                issues.append({
                                    'type': 'WEAK_CIPHER',
                                    'title': 'Weak SSL Cipher',
                                    'description': f'Weak cipher {cipher_name} is supported',
                                    'severity': 'medium',
                                    'evidence': f'Cipher: {cipher_name}, Protocol: {protocol}',
                                    'remediation': 'Disable weak ciphers and use strong encryption'
                                })
                        
                        # Check for old SSL/TLS versions
                        if protocol in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                            issues.append({
                                'type': 'OLD_PROTOCOL',
                                'title': 'Outdated SSL/TLS Protocol',
                                'description': f'Outdated protocol {protocol} is supported',
                                'severity': 'high' if protocol in ['SSLv2', 'SSLv3'] else 'medium',
                                'evidence': f'Protocol: {protocol}',
                                'remediation': 'Disable old SSL/TLS versions and use TLS 1.2 or higher'
                            })
                    
                    # Check certificate validity
                    if cert:
                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        if not_after < datetime.now():
                            issues.append({
                                'type': 'EXPIRED_CERT',
                                'title': 'Expired SSL Certificate',
                                'description': 'SSL certificate has expired',
                                'severity': 'high',
                                'evidence': f'Certificate expired on {cert["notAfter"]}',
                                'remediation': 'Renew SSL certificate'
                            })
                            
        except Exception as e:
            logger.debug(f"SSL analysis error for {host}:{port}: {e}")
            
        return issues

    def _check_web_vulnerabilities(self, host: str, results: List[ScanResult]) -> None:
        """Check for web application vulnerabilities"""
        web_ports = [80, 443, 8080, 8443, 8000, 8888]
        
        for result in results:
            if result.port in web_ports or 'http' in result.service.lower():
                try:
                    base_url = f"{'https' if result.port == 443 or 'https' in result.service else 'http'}://{host}:{result.port}"
                    
                    # Check for common vulnerabilities
                    self._check_directory_traversal(host, result.port, base_url)
                    self._check_information_disclosure_web(host, result.port, base_url)
                    self._check_security_headers(host, result.port, base_url)
                    self._check_common_files(host, result.port, base_url)
                    
                except Exception as e:
                    logger.debug(f"Web vulnerability check failed for {host}:{result.port}: {e}")

    def _check_directory_traversal(self, host: str, port: int, base_url: str) -> None:
        """Check for directory traversal vulnerabilities"""
        traversal_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '../../../windows/win.ini'
        ]
        
        for payload in traversal_payloads:
            try:
                test_url = urljoin(base_url, payload)
                response = requests.get(test_url, timeout=self.timeout, verify=False)
                
                if response.status_code == 200:
                    content = response.text.lower()
                    if 'root:' in content or '[fonts]' in content:
                        vulnerability = Vulnerability(
                            vuln_id=f"DIR_TRAVERSAL_{host}_{port}",
                            title="Directory Traversal Vulnerability",
                            description="The application is vulnerable to directory traversal attacks",
                            severity="high",
                            cvss_score=7.5,
                            affected_service="web",
                            host=host,
                            port=port,
                            evidence=f"Payload '{payload}' returned sensitive file content",
                            remediation="Implement proper input validation and access controls"
                        )
                        self.vulnerabilities.append(vulnerability)
                        break
                        
            except Exception as e:
                logger.debug(f"Directory traversal check failed: {e}")

    def _check_security_headers(self, host: str, port: int, base_url: str) -> None:
        """Check for missing security headers"""
        security_headers = {
            'X-Frame-Options': 'Prevents clickjacking attacks',
            'X-Content-Type-Options': 'Prevents MIME type sniffing',
            'X-XSS-Protection': 'Enables XSS filtering',
            'Strict-Transport-Security': 'Enforces HTTPS connections',
            'Content-Security-Policy': 'Prevents XSS and injection attacks'
        }
        
        try:
            response = requests.get(base_url, timeout=self.timeout, verify=False)
            
            for header, description in security_headers.items():
                if header not in response.headers:
                    security_issue = SecurityIssue(
                        issue_id=f"MISSING_HEADER_{header}_{host}_{port}",
                        category="Security Headers",
                        title=f"Missing Security Header: {header}",
                        description=f"The {header} security header is missing. {description}",
                        risk_level="medium",
                        host=host,
                        service="web",
                        evidence=f"Header '{header}' not found in HTTP response",
                        recommendation=f"Add the {header} header to improve security"
                    )
                    self.security_issues.append(security_issue)
                    
        except Exception as e:
            logger.debug(f"Security headers check failed: {e}")

    def _check_common_files(self, host: str, port: int, base_url: str) -> None:
        """Check for exposed sensitive files and directories"""
        sensitive_paths = [
            '/.git/', '/backup/', '/admin/', '/config/',
            '/phpinfo.php', '/info.php', '/test.php',
            '/robots.txt', '/.htaccess', '/web.config'
        ]
        
        for path in sensitive_paths:
            try:
                test_url = urljoin(base_url, path)
                response = requests.get(test_url, timeout=self.timeout, verify=False)
                
                if response.status_code == 200:
                    vulnerability = Vulnerability(
                        vuln_id=f"EXPOSED_FILE_{path.replace('/', '_')}_{host}_{port}",
                        title=f"Exposed Sensitive Path: {path}",
                        description=f"Sensitive path {path} is accessible",
                        severity="medium" if path in ['/robots.txt'] else "high",
                        affected_service="web",
                        host=host,
                        port=port,
                        evidence=f"Path {path} returned HTTP {response.status_code}",
                        remediation=f"Restrict access to {path} or remove if not needed"
                    )
                    self.vulnerabilities.append(vulnerability)
                    
            except Exception as e:
                logger.debug(f"Common files check failed for {path}: {e}")

    def _check_default_credentials(self, host: str, results: List[ScanResult]) -> None:
        """Check for default credentials on various services"""
        for result in results:
            service = result.service.lower()
            
            if service in ['ssh', 'telnet', 'ftp', 'http', 'https']:
                # This is a simplified check - in practice, you'd use more sophisticated methods
                security_issue = SecurityIssue(
                    issue_id=f"DEFAULT_CREDS_CHECK_{service}_{host}_{result.port}",
                    category="Authentication",
                    title=f"Default Credentials Check Required for {service.upper()}",
                    description=f"Service {service.upper()} should be checked for default credentials",
                    risk_level="high",
                    host=host,
                    service=service,
                    evidence=f"Service {service} detected on port {result.port}",
                    recommendation="Ensure default credentials are changed and strong authentication is implemented"
                )
                self.security_issues.append(security_issue)

    def _check_information_disclosure(self, host: str, results: List[ScanResult]) -> None:
        """Check for information disclosure vulnerabilities"""
        for result in results:
            if result.banner:
                # Check for version information in banners
                if any(keyword in result.banner.lower() for keyword in ['version', 'server', 'apache', 'nginx', 'iis']):
                    security_issue = SecurityIssue(
                        issue_id=f"INFO_DISCLOSURE_{host}_{result.port}",
                        category="Information Disclosure",
                        title="Service Version Information Disclosed",
                        description="Service banner reveals version information that could aid attackers",
                        risk_level="low",
                        host=host,
                        service=result.service,
                        evidence=f"Banner: {result.banner[:100]}",
                        recommendation="Configure services to minimize information disclosure in banners"
                    )
                    self.security_issues.append(security_issue)

    def _check_misconfigurations(self, host: str, results: List[ScanResult]) -> None:
        """Check for common security misconfigurations"""
        open_ports = [r.port for r in results]
        
        # Check for unnecessary services
        dangerous_ports = [23, 135, 139, 445, 1433, 1521, 3306, 5432]
        for port in open_ports:
            if port in dangerous_ports:
                security_issue = SecurityIssue(
                    issue_id=f"DANGEROUS_PORT_{port}_{host}",
                    category="Network Security",
                    title=f"Potentially Dangerous Port Open: {port}",
                    description=f"Port {port} is open and may represent a security risk",
                    risk_level="medium",
                    host=host,
                    service=next((r.service for r in results if r.port == port), "unknown"),
                    evidence=f"Port {port} is accessible",
                    recommendation=f"Ensure port {port} is properly secured or close if not needed"
                )
                self.security_issues.append(security_issue)

    def _generate_summary(self) -> Dict[str, Any]:
        """Generate vulnerability assessment summary"""
        summary = {
            'total_vulnerabilities': len(self.vulnerabilities),
            'total_security_issues': len(self.security_issues),
            'severity_distribution': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            },
            'top_risks': [],
            'affected_hosts': set(),
            'assessment_date': datetime.now().isoformat()
        }
        
        # Count vulnerabilities by severity
        for vuln in self.vulnerabilities:
            summary['severity_distribution'][vuln.severity] += 1
            summary['affected_hosts'].add(vuln.host)
            
        # Convert set to list for JSON serialization
        summary['affected_hosts'] = list(summary['affected_hosts'])
        
        # Identify top risks
        critical_high_vulns = [v for v in self.vulnerabilities if v.severity in ['critical', 'high']]
        summary['top_risks'] = sorted(critical_high_vulns, key=lambda x: x.cvss_score, reverse=True)[:5]
        
        return summary

    def _generate_recommendations(self) -> List[str]:
        """Generate security recommendations based on findings"""
        recommendations = []
        
        if any(v.severity == 'critical' for v in self.vulnerabilities):
            recommendations.append("Address critical vulnerabilities immediately")
            
        if any('ssl' in v.title.lower() for v in self.vulnerabilities):
            recommendations.append("Review and update SSL/TLS configuration")
            
        if any('default' in v.title.lower() for v in self.vulnerabilities):
            recommendations.append("Change all default credentials")
            
        if any('weak' in v.title.lower() for v in self.vulnerabilities):
            recommendations.append("Disable weak protocols and ciphers")
            
        recommendations.extend([
            "Implement network segmentation",
            "Deploy intrusion detection systems",
            "Regular security updates and patches",
            "Conduct periodic security assessments",
            "Implement security monitoring and logging"
        ])
        
        return recommendations

    def export_findings(self, filename: str = "vulnerability_report.json") -> None:
        """Export vulnerability findings to JSON file"""
        logger.info(f"Exporting vulnerability findings to {filename}")
        
        export_data = {
            'vulnerabilities': [
                {
                    'vuln_id': v.vuln_id,
                    'title': v.title,
                    'description': v.description,
                    'severity': v.severity,
                    'cvss_score': v.cvss_score,
                    'host': v.host,
                    'port': v.port,
                    'service': v.affected_service,
                    'evidence': v.evidence,
                    'remediation': v.remediation,
                    'timestamp': v.timestamp.isoformat()
                } for v in self.vulnerabilities
            ],
            'security_issues': [
                {
                    'issue_id': s.issue_id,
                    'category': s.category,
                    'title': s.title,
                    'description': s.description,
                    'risk_level': s.risk_level,
                    'host': s.host,
                    'service': s.service,
                    'evidence': s.evidence,
                    'recommendation': s.recommendation,
                    'timestamp': s.timestamp.isoformat()
                } for s in self.security_issues
            ]
        }
        
        try:
            with open(filename, 'w') as f:
                json.dump(export_data, f, indent=2)
            logger.info(f"Findings exported successfully to {filename}")
        except Exception as e:
            logger.error(f"Failed to export findings: {e}")
